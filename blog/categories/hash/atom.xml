<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: hash | Shady Minds]]></title>
  <link href="http://dyagilev.org/blog/categories/hash/atom.xml" rel="self"/>
  <link href="http://dyagilev.org/"/>
  <updated>2015-03-08T00:26:34+02:00</updated>
  <id>http://dyagilev.org/</id>
  <author>
    <name><![CDATA[Oleksiy Dyagilev]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Consistent Hashing]]></title>
    <link href="http://dyagilev.org/blog/2012/03/23/consistent-hashing/"/>
    <updated>2012-03-23T14:34:54+02:00</updated>
    <id>http://dyagilev.org/blog/2012/03/23/consistent-hashing</id>
    <content type="html"><![CDATA[<p>Техника консистентного хеширования <a href="http://en.wikipedia.org/wiki/Consistent_hashing">consistent hashing</a> довольно популярна при создании распределенных систем, тем не менее я не смог найти описания алгоритма на русском языке. Попробую изложить, возможно кому-то пригодится.</p>

<!-- more -->

<h2 id="section">Проблема</h2>
<p>Предположим вы разрабатываете приложение и решили кешировать данные для улучшения производительности. Так же вы решили использовать горизонтальное масштабирование и разнести данные на N серверов.</p>

<p>Итого, есть N серверов и необходимо реализовать две функции:</p>

<p><code>java
void put(Key k, Item i) // положить элемент i с ключом k в кеш
Item get(Key k); // вытащить элемент по ключу k
</code></p>

<p>Имея ключ k, как узнать на каком сервере лежит соответствующий ему элемент?</p>

<h2 id="section-1">Решение</h2>
<p>Первое что приходит в голову - использовать обычную хеш-таблицу. Берем ключ k, применяем к нему хеш-функцию и считаем остаток от деления на количество серверов N - <code>hash(k) mod N</code>. Да, это будет работать, но что произойдет когда мы захотим добавить ещё один сервер ? Нам необходимо будет перехешировать все данные, большую часть которых нужно будет загрузить на новые сервера. Это дорогая операция. Также не понятно что делать в случае падения существующего сервера.</p>

<p>Здесь появляется консистентное кеширование. Идея простая, возьмем окружность и будем рассматривать ее как интервал на котором определена хеш-функция функция. Применив хеш-функцию к набору ключей (синие точки) и серверов (зеленые точки) сможем разместить их на окружности.</p>

<p><img src="/images/consistent-hashing/consistent_hashing11.png" width="50%" height="50%" /></p>

<p>Для того чтобы определить на каком сервере размещен ключ, найдем ключ на окружности и будем двигаться по часовой стрелке до ближайшего сервера.</p>

<p>Теперь в случае падения (недоступности) сервера, загрузить на новые сервер необходимо только недоступные данные. Все остальные хеши не меняют свое местоположение, то есть консистенты.</p>

<p><img src="/images/consistent-hashing/consistent_hashing2.png" width="50%" height="50%" /></p>

<p>При добавлении нового сервера соседний разделяет с ним часть своих данных.</p>

<p><img src="/images/consistent-hashing/consistent_hashing3.png" width="50%" height="50%" /></p>

<p>В целом ето все. На практике также применяют следующий трюк. Сервер можно пометить на окружности не одной точкой, а несколькими.</p>

<p><img src="/images/consistent-hashing/consistent_hashing4.png" width="50%" height="50%" /></p>

<p>Что ето дает ?
- более равномерное распределение данных по серверам
- при падении сервера данные распределяются не на один соседний, а на несколько, распределяя тем самым нагрузку
- при добавлении нового сервера, точки можно делать ‘активными’ постепенно одна за другой, предотвращая шквальную нагрузку на сервер
- если конфигурация серверов отличается, например размером диска, количество данных можно контролировать числом его точек. Больше точек - большая длина окружности принадлежит етому серверу и соответственно больше данных.</p>

<h2 id="section-2">Реализация</h2>

<p>Храним хеши серверов в виде какого-либо дерева, например Red-Black. Операция поиска сервера по ключу будет занимать <code>O(log n)</code>.</p>

]]></content>
  </entry>
  
</feed>
